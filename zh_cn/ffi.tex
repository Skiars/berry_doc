\chapter{语言交互接口}

\textbf{语言交互接口}（Foreign Function Interface, FFI）是不同语言之间交互的接口。Berry提供了一套FFI来实现与C语言之间的交互，这套接口也非常容易在C++中使用。大部分的FFI接口是一些函数，它们的声明都放在\textit{berry.h}文件中。为了降低RAM的使用量，FFI还提供一套C编译期生成固定哈希表的机制，该机制必须要用到外部工具来生成C代码。

\section{基础}

FFI中最为重要的交互功能的应该是Berry代码与C函数相互调用的功能。为了实现两种语言互相调用对方的函数，我们要先了解Berry函数的参数传递机制。

\subsection{虚拟机}

与编译型语言不同，Berry语言不能直接在物理机器上运行，而是在特定的软件环境中运行，这个环境就是\textbf{虚拟机}（Virtual Machine, VM）。与真实的计算机相似，文本形式的源代码不能在虚拟机中执行，而要通过编译器将其转换为``字节码''才可以。Berry虚拟机定义为一个C结构体 \texttt{bvm}，这个结构体的内容对于FFI而言是不可见的。通过一些FFI函数，我们可以创建并初始化一个虚拟机。我们通过一个简单的例子来介绍虚拟机的使用：
\begin{lstlisting}[language=c, style=berry]
void berry_test(void)
{
    bvm *vm = be_vm_new();                     // Construct a VM
    be_loadlibs(vm);                           // Add libraries
    be_loadstring(vm, "print('Hello Berry')"); // Compile test code
    be_pcall(vm, 0);                           // Call function
    be_vm_delete(vm);                          // Destroy the VM
}
\end{lstlisting}
这段代码给出了一个完整的使用虚拟机例子，首先，调用 \texttt{be\_vm\_new} 函数来构造一个新的虚拟机，之后所有的操作都在这个虚拟机对象中完成。默认情况下，虚拟机中不会加载任何模块或者函数，所以要调用 \texttt{be\_loadlibs} 来加载库，到此虚拟机的初始化工作就完成了。5到6行的作用是将一个字符串中的源代码编译成Berry函数然后调用。最后在第7行调用 \texttt{be\_vm\_delete} 函数销毁虚拟机。执行该函数将会在终端中得到一行输出：
\begin{lstlisting}[numbers=none]
Hello Berry
\end{lstlisting}

在所有的场景之下，虚拟机的构造、库加载以及销毁的流程都和上面例子中的第3行、第4行和第6行一样。更具需要，编译或者加载源代码的方式可能会有所不同，例如，对于文件形式的源代码，可以通过 \texttt{be\_loadfile} 函数来编译。源代码会被编译成一个Berry函数，且该函数会被存放在栈顶，通过调用FFI函数 \texttt{be\_pcall} 或 \texttt{be\_call} 既可执行该Berry函数。你还可以通过 \texttt{be\_repl} 函数来使用REPL，REPL的接口将在相关的章节中描述。

\subsection{虚拟栈}

Berry使用一个虚拟栈（virtual stack）和C语言编写的原生函数传递值，栈中每个元素都是一个Berry值。Berry代码调用原生函数时总会创建一个新的栈，并把所有的参数压入栈中。在C代码中也可以使用这个虚拟栈来存储数据，存储在栈中的值不会被垃圾回收器回收。

\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\begin{tikzpicture}
    \begin{scope}[
    start chain=1 going right,start chain=2 going below,node distance=-0.15mm,minimum width=0.5cm,minimum height=0.6cm,font=\small\ttfamily
  ]
  \node [on chain=1] at (-1.5, -0.4) {\ldots};
  \foreach \x in {-1,...,-7} {
      \x, \node at (3+\x*0.5, 0.2) {\x};
  }
  \node [draw,on chain=1] {};
  \foreach \x in {1,...,7} {
      \x, \node (\x) [draw,on chain=1] {\x};
  }
  \foreach \x in {8,...,10} {
      \x, \node (\x) [draw,on chain=1] {};
  }
  \node [on chain=1] {\ldots};
  \node (base) at (-0.5, -1.2) {base};
  \node (top)  at (3, -1.2) {top};

  \draw[->] (base) -- (1);
  \draw[->] (top) -- (8);
  \end{scope}
\end{tikzpicture}
\caption{虚拟栈}
\label{fig::virtual_stack}
\end{wrapfigure}

Berry使用的虚拟栈如图\ref{fig::virtual_stack}所示，虚拟栈从左往右增长。Berry代码调用一个原生函数时会得到一个初始的堆栈，该堆栈第一个值的位置称为\textbf{栈底}（\texttt{base}），而最后一个位置称为\textbf{栈顶}（\texttt{top}），原生函数只能访问从栈底到栈顶前一个位置间的值。栈底的位置是固定的，而栈顶的位置则可以移动，并且栈顶永远为空，产生这个性质的原因是：将新的值压入虚拟栈以后，原来栈顶的位置将会写入新的值，此时栈顶指针会向前挪到下一个位置；反过来，如果将虚拟栈顶部的值弹出，栈顶指针会减$1$，此时栈顶指针的位置虽然客观上有值，但是这个值是无效的，并随时可能被清除，因此栈顶指针位置依然是空的。虚拟栈为空时，栈底指针 \texttt{base} 等于栈顶指针 \texttt{top}。虚拟堆栈不严格遵循栈的操作规则：除了push和pop以外，虚拟栈还可以通过索引来访问，甚至可以在任意位置插入或者删除值。索引栈中元素的方法有两种：一种是以栈底为参考的\textbf{绝对索引}，绝对索引值是从$1$开始的正整数；另一种是以栈顶为参考的\textbf{相对索引}，相对索引值是从$-1$开始的负整数。以图\ref{fig::virtual_stack}为例，索引值$1,2\ldots 8$是绝对索引，元素的绝对索引就是该元素到栈底的距离。索引值$-1,-2\ldots -8$是相对索引，元素的相对索引值为该元素到栈顶距离的负数。如果一个索引值$index$有效，那么它所指的元素应该处于栈底到栈顶之间，也就是满足表达式$1\leq \mathrm{abs}(index)\leq top-base+1$。

为了方便起见，我们规定以栈底指针 \texttt{base} 作为参考，其绝对索引$1$，并且不考虑 \texttt{base} 前面的值（通常，\texttt{base} 并不是整个栈最底部的位置）。例如，原生函数返回时，存储返回值的位置就在 \texttt{base} 之前，这些位置通常不允许原生函数访问。

\subsection{操作虚拟栈}

\subsubsection{索引和栈尺寸}

前面已经提到，可以使用两种索引方式访问虚拟栈，并且要保证索引值有效。同时，在很多时候也需要将新的值压入堆栈，此时须要程序员自己保证堆栈不会溢出。默认情况下，Berry保证有 \texttt{BE\_STACK\_FREE\_MIN} 个空间供原生函数使用，这个值可以在文件\textit{berry.h}中修改，它的默认值通常是$10$，在大多数情况下应该够用。如果确实需要扩充堆栈则，可以通过调用FFI函数 \texttt{be\_stack\_require} 来实现。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_stack_require(bvm *vm, int count)；
\end{lstlisting}
参数 \texttt{count} 为需要的空间数量，当虚拟栈剩余的空位不足时将会扩展堆栈容量，否则这个函数什么也不做。

\textbf{警告}：如果发生了堆栈溢出，或者使用无效的索引访问堆栈都会导致程序崩溃。你可以打开调试开关 \texttt{BE\_DEBUG}，这会打开断言功能，可以在运行时得到一些调试信息，以便捕获堆栈溢出或者无效索引这类错误。

\subsubsection{从栈中获取值}

FFI中有一组函数用于从虚拟栈中获取值，这些函数通常会将栈中的值转换为C语言支持的简单值然后返回，以下是常用的从栈中获取值的FFI：
\begin{lstlisting}[language=c, style=berry, numbers=none]
bint be_toint(bvm *vm, int index);
breal be_toreal(bvm *vm, int index);
int be_tobool(bvm *vm, int index);
const char* be_tostring(bvm *vm, int index);
void* be_tocomptr(bvm *vm, int index);
\end{lstlisting}
这些函数的参数形式相同，只是返回值不同。前4个函数的作用和容易理解，就像它们的名字一样，\texttt{be\_toint} 的功能是将虚拟栈中的值转换为C的整型值（\texttt{bint} 通常是 \texttt{int} 类型的别名）并返回。最后一个函数 \texttt{be\_tocomptr} 的作用是从虚拟栈中取出一个通用类型的指针值，这个指针具体有何意义由C程序自己解释。

这些函数使用相同的方式去解释参数：参数 \texttt{vm} 是虚拟机实例的指针；\texttt{index} 为待取出元素的索引，它可以是相对索引或绝对索引。无法使用FFI将Berry的复杂数据类型从虚拟栈中取出，因此你无法将一个 \texttt{map} 类型或者 \texttt{class} 类型从栈中取出。这种设计的好处之一是不需要在原生函数中考虑垃圾回收的问题。

\subsection{原生函数}

\textbf{原生函数}是由C语言实现的，可供Berry代码调用的函数。原生函数可以是一个普通的函数，这种情况下，调用原生函数不会附加生成任何动态分配的空间，就像一般的C函数调用一样。原生函数也可以是闭包，在创建原生闭包时需要为自由变量分配空间。通常情况下，简单的原生函数就足够满足需求，它们比原生闭包更节省资源，同时使用上也更加简单。

\subsubsection{定义原生函数}

原生函数本身是一个C函数，不过它们都具有特定的形式。原生函数的定义形式为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int a_native_function(bvm *vm)
{
    // do something ...
}
\end{lstlisting}
原生函数必须是参数是一个 \texttt{bvm} 指针，返回值为 \texttt{int} 类型的C函数。Berry的函数必须返回一个值，原生函数也不例外。与C语言的返回值不同，原生函数的返回值并不是C的 \texttt{return} 语句所携带的值。你可以使用这些FFI返回原生函数的值，同时它们也会使C函数返回：
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_return(bvm *vm);
be_return_nil(bvm *vm);
\end{lstlisting}
这些FFI实际上是两个宏，使用它们的时候不需要再使用C的 \texttt{return} 语句。\texttt{be\_return} 会将虚拟栈中的顶部

\subsubsection{使用原生函数}

定义原生函数之后必须要使用某种方法添加到解释器中才能在Berry代码中调用。最简单的办法是把原生函数添加到Berry全局变量中。我们把使用FFI将某个原生对象添加到Berry全局变量中的过程称为\textbf{注册}。注册原生函数的FFI为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_regfunc(bvm *vm, const char *name, bntvfunc f);
\end{lstlisting}
\texttt{vm} 是当前的虚拟机实例，\texttt{name} 是该原生函数的全局变量名称，\texttt{f} 是原生函数的指针。类型 \texttt{bntvfunc} 的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
实际上 \texttt{bntvfunc} 类型就是参数为 \texttt{bvm} 且返回值类型为 \texttt{int} 的函数指针类型。\texttt{be\_regfunc} 函数要在解析Berry源代码之前调用。

也可以将原生函数压入虚拟栈中，然后可以使用FFI \texttt{be\_call} 来调用它，更常见的用法是把虚拟栈中原生函数对象作为返回值。

\subsubsection{完整的例子}

我们用一个简单的示例结束本节，在这里，我们呢要实现一个 \texttt{add} 函数，该函数用于将两个数相加，然后返回计算结果。首先，我们定义一个原生函数实现此功能：
\begin{lstlisting}[language=c, style=berry]
static int l_add(bvm *vm)
{
    int top = be_top(vm); // Get the number of arguments
    /* Verify the number and type of arguments */
    if (top == 2 && be_isnumber(vm, 1) && be_isnumber(vm, 1)) {
        breal x = be_toreal(vm, 1); // Get the first argument
        breal y = be_toreal(vm, 2); // Get the second argument
        be_pushreal(vm, x + y);     // Push the result onto the stack
        be_return(vm);              // Return the value at the top of the stack
    }
    be_return_nil(vm); // Return nil when something goes wrong
}
\end{lstlisting}
原生函数通常不需要在C文件外部使用，因此一般将它们声明为 \texttt{static} 类型。使用 \texttt{be\_top} 函数可以获得虚拟栈的栈顶绝对索引（\texttt{top} 值），也就是栈的容量。我们可以在原生函数进行虚拟栈的操作之前调用 \texttt{be\_top}，此时虚拟栈容量等于实参数量。对于 \texttt{add} 函数，我们需要两个参数参与运算，因此在第4行检查参数数量是否为2（\texttt{top == 2}）。并且我们需要检查两个参数是否都是数值类型，因此要调用 \texttt{be\_isnumber} 函数来检查。如果一切无误，就会从虚拟栈中取出参数，然后将计算结果入栈，最后使用 \texttt{be\_return} 返回。如果参数验证失败则会调用 \texttt{be\_return\_nil} 返回 \texttt{nil} 值。

接下来我们将这个原生函数注册到全局变量中，简单起见，我们在加载库之后注册它：
\begin{lstlisting}[language=c, style=berry]
bvm *vm = be_vm_new();          // Construct a VM
be_loadlibs(vm);                // Add libraries
be_regfunc(vm, "myadd", l_add); // Register the native function "myadd"
\end{lstlisting}
第3行就是注册该原生函数的位置，我们将它命名为 \texttt{myadd}。到此，原生函数的定义和注册就完成了。作为验证，你可以编译解释器，然后进入REPL，运行一些测试。你应该会得到这样的结果：
\begin{lstlisting}[language=berry, numbers=none]
> myadd
<function: 0x562a210f0f90>
> myadd(1.0, 2.5)
3.5
> myadd(2.5, 2)
4.5
> myadd(1, 2)
3
\end{lstlisting}

\section{类型和函数}

\subsection{类型}

本节将介绍FFI中需要使用的一些类型，这些类型一般由FFI函数使用。通常，FFI中的类型和声明都可以在 \textit{berry.h} 文件中找到，本节内容如无特别说明，默认其定义或声明在 \textit{berry.h} 中提供。

\ffititle{bvm}

\texttt{bvm} 类型用于存储Berry虚拟机的状态信息。这个类型的细节对外部程序不可见。因此只能在 \textit{berry.h} 文件中找到这样的定义：
\begin{lstlisting}[language=c, numbers=none]
typedef struct bvm bvm;
\end{lstlisting}

大部分的FFI函数都使用 \texttt{bvm} 类型作为第一个参数，这是因为它们内部都要操作虚拟机。隐藏 \texttt{bvm} 的内部实现有利于降低 FFI 标准与 VM 之间的耦合性。在解释器外部，通常只用 \texttt{bvm} 的指针。创建一个新的 \texttt{bvm} 对象要使用 \texttt{be\_vm\_new} 函数，销毁 \texttt{bvm} 对象应使用 \texttt{be\_vm\_delete} 函数。

\ffititle{bntvfunc}

原生函数类型。该类型的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
这个类型是原生函数指针，一些将原生函数注册或添加到虚拟机中的FFI使用该类型的参数。该类型的变量或参数需要使用参数为 \texttt{bvm} 类型，返回值为 \texttt{int} 类型的函数名来初始化。

\ffititle{bnfuncinfo}

该类型用于批量注册原生函数或是构建原生类时使用，其定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef struct {
    const char *name;   // The name of the function or object
    bntvfunc function;  // The function pointer
} bnfuncinfo;
\end{lstlisting}
\texttt{bnfuncinfo} 的 \texttt{name} 成员表示函数或者对象的名字，而 \texttt{function} 成员为原生函数指针。

\ffititle{bint}

该类型是Berry内置的整数类型。默认情况下 \texttt{bint} 使用 \texttt{int} 类型实现，其定义在 \textit{berry.h} 文件中：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int bint;
\end{lstlisting}
确实有必要的话，你可以修改此处的定义。但我们没有测试过其他的 \texttt{bint} 实现方式的可行性。

\ffititle{breal}

这是 Berry 内置的实数类型，实际上就是C语言中的浮点类型。\texttt{breal} 的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
#if BE_SINGLE_FLOAT != 0
    typedef float       breal;
#else
    typedef double      breal;
#endif
\end{lstlisting}
你可以使用宏 \texttt{BE\_SINGLE\_FLOAT} 来控制 \texttt{breal} 的具体实现：当 \texttt{BE\_SINGLE\_FLOAT} 的值为 \texttt{0} 时将使用 \texttt{double} 类型实现 \texttt{breal}，否则使用 \texttt{float} 类型实现 \texttt{breal}。

\ffititle{berrorcode}

这个枚举类型在一些 FFI 的返回值中使用，此类型的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
enum berrorcode {
    BE_OK = 0,
    BE_IO_ERROR,
    BE_SYNTAX_ERROR,
    BE_EXEC_ERROR,
    BE_MALLOC_FAIL,
    BE_EXIT
};
\end{lstlisting}
这些枚举值的含义为：
\begin{itemize}
    \item \texttt{BE\_OK}：没有任何错误，函数执行成功。
    \item \texttt{BE\_IO\_ERROR}：解释器在读取源文件时发生文件读取错误，该错误一般是由于文件不存在而导致的。
    \item \texttt{BE\_SYNTAX\_ERROR}：解释器在编译源代码时发生语法错误。发生此错误以后解释器不会生成字节码，因此也不能继续执行字节码。
    \item \texttt{BE\_EXEC\_ERROR}：运行时错误。发生此错误时会停止执行 Berry 代码并将环境恢复到最近的恢复点。
    \item \texttt{BE\_MALLOC\_FAIL}：内存分配失败。此错误由堆空间不足导致。
    \item \texttt{BE\_EXIT}：表示程序退出，该枚举值不是错误。执行 Berry 的 \texttt{exit} 函数会使解释器返回这个值。
\end{itemize}

\subsection{函数}

\ffititle{be\_vm\_new}

该函数用于建立一个新的虚拟机实例。其声明为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
bvm* be_vm_new(void);
\end{lstlisting}
函数的返回值是虚拟机实例的指针。使用 \texttt{be\_vm\_new} 创建虚拟机的过程仅初始化虚拟机必须的组件而不会加载库，因此所有的内置函数和类都不会在该函数的调用过程中加载。

\ffititle{be\_vm\_delete}

该函数用于销毁一个虚拟机实例，函数声明为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_vm_delete(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 是待销毁的虚拟机对象指针。销毁虚拟机将会连带释放虚拟机中所有的对象，包括栈中的值以及由 GC 管理的对象。销毁后的虚拟机指针将是一个无效值，不可以再引用它。

\section{配置文件}

\section{模块}

\section{编译期 Hash 技术}

\subsection{编译期字符串表}

\subsection{编译期构造类}

\subsection{编译期构造模块}
