\chapter{语言交互接口}

\textbf{语言交互接口}（Foreign Function Interface, FFI）是不同语言之间交互的接口。Berry提供了一套FFI来实现与C语言之间的交互，这套接口也非常容易在C++中使用。大部分的FFI接口是一些函数，它们的声明都放在\textit{berry.h}文件中。为了降低RAM的使用量，FFI还提供一套C编译期生成固定哈希表的机制，该机制必须要用到外部工具来生成C代码。

\section{基础}

FFI中最为重要的交互功能的应该是Berry代码与C函数相互调用的功能。为了实现两种语言互相调用对方的函数，我们要先了解Berry函数的参数传递机制。

\subsection{虚拟机}

与编译型语言不同，Berry语言不能直接在物理机器上运行，而是在特定的软件环境中运行，这个环境就是\textbf{虚拟机}（Virtual Machine, VM）。与真实的计算机相似，文本形式的源代码不能在虚拟机中执行，而要通过编译器将其转换为``字节码''才可以。Berry虚拟机定义为一个C结构体 \texttt{bvm}，这个结构体的内容对于FFI而言是不可见的。通过一些FFI函数，我们可以创建并初始化一个虚拟机。我们通过一个简单的例子来介绍虚拟机的使用：
\begin{lstlisting}[language=c, style=berry]
void berry_test(void)
{
    bvm *vm = be_vm_new();                     // Construct a VM
    be_loadlibs(vm);                           // Add libraries
    be_loadstring(vm, "print('Hello Berry')"); // Compile test code
    be_pcall(vm, 0);                           // Call function
    be_vm_delete(vm);                          // Destroy the VM
}
\end{lstlisting}
这段代码给出了一个完整的使用虚拟机例子，首先，调用 \texttt{be\_vm\_new} 函数来构造一个新的虚拟机，之后所有的操作都在这个虚拟机对象中完成。默认情况下，虚拟机中不会加载任何模块或者函数，所以要调用 \texttt{be\_loadlibs} 来加载库，到此虚拟机的初始化工作就完成了。5到6行的作用是将一个字符串中的源代码编译成Berry函数然后调用。最后在第7行调用 \texttt{be\_vm\_delete} 函数销毁虚拟机。执行该函数将会在终端中得到一行输出：
\begin{lstlisting}[numbers=none]
Hello Berry
\end{lstlisting}

在所有的场景之下，虚拟机的构造、库加载以及销毁的流程都和上面例子中的第3行、第4行和第6行一样。更具需要，编译或者加载源代码的方式可能会有所不同，例如，对于文件形式的源代码，可以通过 \texttt{be\_loadfile} 函数来编译。源代码会被编译成一个Berry函数，且该函数会被存放在栈顶，通过调用FFI函数 \texttt{be\_pcall} 或 \texttt{be\_call} 既可执行该Berry函数。你还可以通过 \texttt{be\_repl} 函数来使用REPL，REPL的接口将在相关的章节中描述。

\subsection{虚拟栈}

Berry使用一个虚拟栈（virtual stack）和C语言编写的原生函数传递值，栈中每个元素都是一个Berry值。Berry代码调用原生函数时总会创建一个新的栈，并把所有的参数压入栈中。在C代码中也可以使用这个虚拟栈来存储数据，存储在栈中的值不会被垃圾回收器回收。

\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\begin{tikzpicture}
    \begin{scope}[
    start chain=1 going right,start chain=2 going below,node distance=-0.15mm,minimum width=0.5cm,minimum height=0.6cm,font=\small\ttfamily
  ]
  \node [on chain=1] at (-1.5, -0.4) {\ldots};
  \foreach \x in {-1,...,-7} {
      \x, \node at (3+\x*0.5, 0.2) {\x};
  }
  \node [draw,on chain=1] {};
  \foreach \x in {1,...,7} {
      \x, \node (\x) [draw,on chain=1] {\x};
  }
  \foreach \x in {8,...,10} {
      \x, \node (\x) [draw,on chain=1] {};
  }
  \node [on chain=1] {\ldots};
  \node (base) at (-0.5, -1.2) {base};
  \node (top)  at (3, -1.2) {top};

  \draw[->] (base) -- (1);
  \draw[->] (top) -- (8);
  \end{scope}
\end{tikzpicture}
\caption{虚拟栈}
\label{fig::virtual_stack}
\end{wrapfigure}

Berry使用的虚拟栈如图\ref{fig::virtual_stack}所示，虚拟栈从左往右增长。Berry代码调用一个原生函数时会得到一个初始的堆栈，该堆栈第一个值的位置称为\textbf{栈底}（\texttt{base}），而最后一个位置称为\textbf{栈顶}（\texttt{top}），原生函数只能访问从栈底到栈顶前一个位置间的值。栈底的位置是固定的，而栈顶的位置则可以移动，并且栈顶永远为空，产生这个性质的原因是：将新的值压入虚拟栈以后，原来栈顶的位置将会写入新的值，此时栈顶指针会向前挪到下一个位置；反过来，如果将虚拟栈顶部的值弹出，栈顶指针会减$1$，此时栈顶指针的位置虽然客观上有值，但是这个值是无效的，并随时可能被清除，因此栈顶指针位置依然是空的。虚拟栈为空时，栈底指针 \texttt{base} 等于栈顶指针 \texttt{top}。虚拟堆栈不严格遵循栈的操作规则：除了push和pop以外，虚拟栈还可以通过索引来访问，甚至可以在任意位置插入或者删除值。索引栈中元素的方法有两种：一种是以栈底为参考的\textbf{绝对索引}，绝对索引值是从$1$开始的正整数；另一种是以栈顶为参考的\textbf{相对索引}，相对索引值是从$-1$开始的负整数。以图\ref{fig::virtual_stack}为例，索引值$1,2\ldots 8$是绝对索引，元素的绝对索引就是该元素到栈底的距离。索引值$-1,-2\ldots -8$是相对索引，元素的相对索引值为该元素到栈顶距离的负数。如果一个索引值$index$有效，那么它所指的元素应该处于栈底到栈顶之间，也就是满足表达式$1\leq \mathrm{abs}(index)\leq top-base+1$。

为了方便起见，我们规定以栈底指针 \texttt{base} 作为参考，其绝对索引$1$，并且不考虑 \texttt{base} 前面的值（通常，\texttt{base} 并不是整个栈最底部的位置）。例如，原生函数返回时，存储返回值的位置就在 \texttt{base} 之前，这些位置通常不允许原生函数访问。

\subsection{操作虚拟栈}

\subsubsection{索引和栈尺寸}

前面已经提到，可以使用两种索引方式访问虚拟栈，并且要保证索引值有效。同时，在很多时候也需要将新的值压入堆栈，此时须要程序员自己保证堆栈不会溢出。默认情况下，Berry保证有 \texttt{BE\_STACK\_FREE\_MIN} 个空间供原生函数使用，这个值可以在文件\textit{berry.h}中修改，它的默认值通常是$10$，在大多数情况下应该够用。如果确实需要扩充堆栈则，可以通过调用FFI函数 \texttt{be\_stack\_require} 来实现。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_stack_require(bvm *vm, int count)；
\end{lstlisting}
参数 \texttt{count} 为需要的空间数量，当虚拟栈剩余的空位不足时将会扩展堆栈容量，否则这个函数什么也不做。

\textbf{警告}：如果发生了堆栈溢出，或者使用无效的索引访问堆栈都会导致程序崩溃。你可以打开调试开关 \texttt{BE\_DEBUG}（\ref{section::BE_DEBUG}节），这会打开断言功能，可以在运行时得到一些调试信息，以便捕获堆栈溢出或者无效索引这类错误。

\subsubsection{从栈中获取值}

FFI中有一组函数用于从虚拟栈中获取值，这些函数通常会将栈中的值转换为C语言支持的简单值然后返回，以下是常用的从栈中获取值的FFI：
\begin{lstlisting}[language=c, style=berry, numbers=none]
bint be_toint(bvm *vm, int index);
breal be_toreal(bvm *vm, int index);
int be_tobool(bvm *vm, int index);
const char* be_tostring(bvm *vm, int index);
void* be_tocomptr(bvm *vm, int index);
\end{lstlisting}
这些函数的参数形式相同，只是返回值不同。前4个函数的作用和容易理解，就像它们的名字一样，\texttt{be\_toint} 的功能是将虚拟栈中的值转换为C的整型值（\texttt{bint} 通常是 \texttt{int} 类型的别名）并返回。最后一个函数 \texttt{be\_tocomptr} 的作用是从虚拟栈中取出一个通用类型的指针值，这个指针具体有何意义由C程序自己解释。

这些函数使用相同的方式去解释参数：参数 \texttt{vm} 是虚拟机实例的指针；\texttt{index} 为待取出元素的索引，它可以是相对索引或绝对索引。无法使用FFI将Berry的复杂数据类型从虚拟栈中取出，因此你无法将一个 \texttt{map} 类型或者 \texttt{class} 类型从栈中取出。这种设计的好处之一是不需要在原生函数中考虑垃圾回收的问题。

\subsection{原生函数}

\textbf{原生函数}是由C语言实现的，可供Berry代码调用的函数。原生函数可以是一个普通的函数，这种情况下，调用原生函数不会附加生成任何动态分配的空间，就像一般的C函数调用一样。原生函数也可以是闭包，在创建原生闭包时需要为自由变量分配空间。通常情况下，简单的原生函数就足够满足需求，它们比原生闭包更节省资源，同时使用上也更加简单。

\subsubsection{定义原生函数}

原生函数本身是一个C函数，不过它们都具有特定的形式。原生函数的定义形式为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int a_native_function(bvm *vm)
{
    // do something ...
}
\end{lstlisting}
原生函数必须是参数是一个 \texttt{bvm} 指针，返回值为 \texttt{int} 类型的C函数。Berry的函数必须返回一个值，原生函数也不例外。与C语言的返回值不同，原生函数的返回值并不是C的 \texttt{return} 语句所携带的值。你可以使用这些FFI返回原生函数的值，同时它们也会使C函数返回：
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_return(bvm *vm);
be_return_nil(bvm *vm);
\end{lstlisting}
这些FFI实际上是两个宏，使用它们的时候不需要再使用C的 \texttt{return} 语句。\texttt{be\_return} 会将虚拟栈中的顶部

\subsubsection{使用原生函数}

定义原生函数之后必须要使用某种方法添加到解释器中才能在Berry代码中调用。最简单的办法是把原生函数添加到Berry全局变量中。我们把使用FFI将某个原生对象添加到Berry全局变量中的过程称为\textbf{注册}。注册原生函数的FFI为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_regfunc(bvm *vm, const char *name, bntvfunc f);
\end{lstlisting}
\texttt{vm} 是当前的虚拟机实例，\texttt{name} 是该原生函数的全局变量名称，\texttt{f} 是原生函数的指针。类型 \texttt{bntvfunc} 的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
实际上 \texttt{bntvfunc} 类型就是参数为 \texttt{bvm} 且返回值类型为 \texttt{int} 的函数指针类型。\texttt{be\_regfunc} 函数要在解析Berry源代码之前调用。

也可以将原生函数压入虚拟栈中，然后可以使用FFI \texttt{be\_call} 来调用它，更常见的用法是把虚拟栈中原生函数对象作为返回值。

\subsubsection{完整的例子}

我们用一个简单的示例结束本节，在这里，我们呢要实现一个 \texttt{add} 函数，该函数用于将两个数相加，然后返回计算结果。首先，我们定义一个原生函数实现此功能：
\begin{lstlisting}[language=c, style=berry]
static int l_add(bvm *vm)
{
    int top = be_top(vm); // Get the number of arguments
    /* Verify the number and type of arguments */
    if (top == 2 && be_isnumber(vm, 1) && be_isnumber(vm, 1)) {
        breal x = be_toreal(vm, 1); // Get the first argument
        breal y = be_toreal(vm, 2); // Get the second argument
        be_pushreal(vm, x + y);     // Push the result onto the stack
        be_return(vm);              // Return the value at the top of the stack
    }
    be_return_nil(vm); // Return nil when something goes wrong
}
\end{lstlisting}
原生函数通常不需要在C文件外部使用，因此一般将它们声明为 \texttt{static} 类型。使用 \texttt{be\_top} 函数可以获得虚拟栈的栈顶绝对索引（\texttt{top} 值），也就是栈的容量。我们可以在原生函数进行虚拟栈的操作之前调用 \texttt{be\_top}，此时虚拟栈容量等于实参数量。对于 \texttt{add} 函数，我们需要两个参数参与运算，因此在第4行检查参数数量是否为2（\texttt{top == 2}）。并且我们需要检查两个参数是否都是数值类型，因此要调用 \texttt{be\_isnumber} 函数来检查。如果一切无误，就会从虚拟栈中取出参数，然后将计算结果入栈，最后使用 \texttt{be\_return} 返回。如果参数验证失败则会调用 \texttt{be\_return\_nil} 返回 \texttt{nil} 值。

接下来我们将这个原生函数注册到全局变量中，简单起见，我们在加载库之后注册它：
\begin{lstlisting}[language=c, style=berry]
bvm *vm = be_vm_new();          // Construct a VM
be_loadlibs(vm);                // Add libraries
be_regfunc(vm, "myadd", l_add); // Register the native function "myadd"
\end{lstlisting}
第3行就是注册该原生函数的位置，我们将它命名为 \texttt{myadd}。到此，原生函数的定义和注册就完成了。作为验证，你可以编译解释器，然后进入REPL，运行一些测试。你应该会得到这样的结果：
\begin{lstlisting}[language=berry, numbers=none]
> myadd
<function: 0x562a210f0f90>
> myadd(1.0, 2.5)
3.5
> myadd(2.5, 2)
4.5
> myadd(1, 2)
3
\end{lstlisting}

\section{类型和函数}

\subsection{类型}

本节将介绍FFI中需要使用的一些类型，这些类型一般由FFI函数使用。通常，FFI中的类型和声明都可以在 \textit{berry.h} 文件中找到，本节内容如无特别说明，默认其定义或声明在 \textit{berry.h} 中提供。

\ffititle{bvm}

\texttt{bvm} 类型用于存储Berry虚拟机的状态信息。这个类型的细节对外部程序不可见。因此只能在 \textit{berry.h} 文件中找到这样的定义：
\begin{lstlisting}[language=c, numbers=none]
typedef struct bvm bvm;
\end{lstlisting}

大部分的FFI函数都使用 \texttt{bvm} 类型作为第一个参数，这是因为它们内部都要操作虚拟机。隐藏 \texttt{bvm} 的内部实现有利于降低 FFI 标准与 VM 之间的耦合性。在解释器外部，通常只用 \texttt{bvm} 的指针。创建一个新的 \texttt{bvm} 对象要使用 \texttt{be\_vm\_new} 函数，销毁 \texttt{bvm} 对象应使用 \texttt{be\_vm\_delete} 函数。

\ffititle{bntvfunc}

原生函数类型。该类型的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
这个类型是原生函数指针，一些将原生函数注册或添加到虚拟机中的FFI使用该类型的参数。该类型的变量或参数需要使用参数为 \texttt{bvm} 类型，返回值为 \texttt{int} 类型的函数名来初始化。

\ffititle{bnfuncinfo}

该类型用于批量注册原生函数或是构建原生类时使用，其定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef struct {
    const char *name;   // The name of the function or object
    bntvfunc function;  // The function pointer
} bnfuncinfo;
\end{lstlisting}
\texttt{bnfuncinfo} 的 \texttt{name} 成员表示函数或者对象的名字，而 \texttt{function} 成员为原生函数指针。

\ffititle{bint}

该类型是Berry内置的整数类型。默认情况下 \texttt{bint} 使用 \texttt{int} 类型实现，其定义在 \textit{berry.h} 文件中：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int bint;
\end{lstlisting}
确实有必要的话，你可以修改此处的定义。但我们没有测试过其他的 \texttt{bint} 实现方式的可行性。

\ffititle{breal}

这是 Berry 内置的实数类型，实际上就是C语言中的浮点类型。\texttt{breal} 的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
#if BE_SINGLE_FLOAT != 0
    typedef float       breal;
#else
    typedef double      breal;
#endif
\end{lstlisting}
你可以使用宏 \texttt{BE\_SINGLE\_FLOAT} 来控制 \texttt{breal} 的具体实现：当 \texttt{BE\_SINGLE\_FLOAT} 的值为 \texttt{0} 时将使用 \texttt{double} 类型实现 \texttt{breal}，否则使用 \texttt{float} 类型实现 \texttt{breal}。

\ffititle{berrorcode} \label{section::errorcode}

这个枚举类型在一些 FFI 的返回值中使用，此类型的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
enum berrorcode {
    BE_OK = 0,
    BE_IO_ERROR,
    BE_SYNTAX_ERROR,
    BE_EXEC_ERROR,
    BE_MALLOC_FAIL,
    BE_EXIT
};
\end{lstlisting}
这些枚举值的含义为：
\begin{itemize}
    \item \texttt{BE\_OK}：没有任何错误，函数执行成功。
    \item \texttt{BE\_IO\_ERROR}：解释器在读取源文件时发生文件读取错误，该错误一般是由于文件不存在而导致的。
    \item \texttt{BE\_SYNTAX\_ERROR}：解释器在编译源代码时发生语法错误。发生此错误以后解释器不会生成字节码，因此也不能继续执行字节码。
    \item \texttt{BE\_EXEC\_ERROR}：运行时错误。发生此错误时会停止执行 Berry 代码并将环境恢复到最近的恢复点。
    \item \texttt{BE\_MALLOC\_FAIL}：内存分配失败。此错误由堆空间不足导致。
    \item \texttt{BE\_EXIT}：表示程序退出，该枚举值不是错误。执行 Berry 的 \texttt{exit} 函数会使解释器返回这个值。
\end{itemize}

需要注意的是，发生 \texttt{BE\_MALLOC\_FAIL} 错误时不能够再进行动态内存分配，这意味着不能再分配字符串对象，因此返回这个错误的函数通常不会再给出更详细的错误信息。

\subsection{函数和宏}

\ffititle{be\_vm\_new}

该函数用于建立一个新的虚拟机实例。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
bvm* be_vm_new(void);
\end{lstlisting}
函数的返回值是虚拟机实例的指针。使用 \texttt{be\_vm\_new} 创建虚拟机的过程仅初始化虚拟机必须的组件而不会加载库，因此所有的内置函数和类都不会在该函数的调用过程中加载。

\ffititle{be\_vm\_delete}

该函数用于销毁一个虚拟机实例，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_vm_delete(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 是待销毁的虚拟机对象指针。销毁虚拟机将会连带释放虚拟机中所有的对象，包括栈中的值以及由 GC 管理的对象。销毁后的虚拟机指针将是一个无效值，不可以再引用它。

\ffititle{be\_loadlibs}

该函数用于加载 Berry 库，包括原生函数，原生类和原生模块等。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_loadlibs(bvm *vm);
\end{lstlisting}
一般来说，在使用 \texttt{be\_vm\_new} 构造虚拟机之后都要使用该函数来加载库，否则将无法正常使用 Berry 的大部分功能。如果需要从标准库中移除某些功能，可以根据需要裁剪具体的模块，但不要忘了调用 \texttt{be\_loadlibs} 函数。

\ffititle{be\_loadbuffer}

这个函数用于从缓冲区中加载一段源代码并将其编译为字节码。函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_loadbuffer(bvm *vm, const char *name, const char *buffer, size_t length);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机指针。\texttt{name} 是一个字符串，它通常用来标记源代码的来源，例如从标准输入设备中输入的源代码可以把字符串 \texttt{"stdin"} 传给此参数，而从文件输入的源代码则可以将文件名传给此参数。\texttt{buffer} 参数是存放源代码的缓冲区，这个缓冲区的组织方式和C的字符串很相似，都是字符构成的连续序列，只是 \texttt{buffer} 指向的缓冲区不要求以 \texttt{'\textbackslash 0'} 字符作为结束符。\texttt{length} 参数表示缓冲区长度，这个长度是指缓冲区内源代码文本的字节数量。

举一个简单的例子，如果我们要使用 \texttt{be\_loadbuffer} 函数来编译一个字符串，一般的用法是：
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char *str = "print('Hello Berry')";
be_loadbuffer(vm, "string", str, strlen(str));
\end{lstlisting}
这里我们使用字符串 \texttt{"string"} 来表示源码，你也可以把它修改为任何值。注意这里使用 C 标准库函数 \texttt{strlen} 函数来获取字符串缓冲区长度（其实就是字符串的字节数量）。

如果编译成功，\texttt{be\_loadbuffer} 会把源代码编译成一个 Berry 函数，并把它放在虚拟栈顶部。如果编译遇到错误，\texttt{be\_loadbuffer} 会返回 \texttt{berrorcode} 类型的错误值（\ref{section::errorcode}节），如果可以的话，还会把具体的错误信息字符串存放在虚拟栈顶部。

\ffititle{be\_loadstring}

\texttt{be\_loadstring}是一个宏，其定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
#define be_loadstring(vm, str)  be_loadbuffer((vm), "string", (str), strlen(str))
\end{lstlisting}
这个宏只是对 \texttt{be\_loadbuffer} 函数的简单封装。\texttt{vm} 参数是虚拟机实例的指针，\texttt{str} 参数是源代码字符串的指针。使用 \texttt{be\_loadstring} 来编译字符串十分方便，例如：
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_loadstring(vm, "print('Hello Berry')");
\end{lstlisting}
这种写法要比使用 \texttt{be\_loadbuffer} 时简洁，但是必须保证字符串以 \texttt{'\textbackslash 0'} 字符结尾。

\ffititle{be\_loadfile}

这个函数用于编译一个源代码文件。其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_loadfile(bvm *vm, const char *name);
\end{lstlisting}
该函数的作用与 \texttt{be\_loadbuffer} 函数相似，只不过该函数会通过读取源代码文件来进行编译。参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{name} 为源文件的文件名。这个函数会调用文件接口，默认情况下会使用 C 标准库中的 \texttt{fopen} 等函数来操作文件。

如果使用 C 标准库的文件接口，你可以使用相对路劲或者绝对路径的文件名。如果文件不存在，\texttt{be\_loadfile} 将返回一个 \texttt{BE\_IO\_ERROR} 错误（\ref{section::errorcode}节），同时会将错误信息压入栈顶。其他的错误信息与 \texttt{be\_loadbuffer} 函数相同。建议用 \texttt{be\_loadfile} 函数来编译源文件，而不要将源文件全部读取到一个缓冲区中，然后调用 \texttt{be\_loadbuffer} 函数编译源代码。前者会分段读取源文件，并只在内存中建立小的读取缓冲区，因而更加节约内存。

\ffititle{be\_top}

这个函数返回虚拟栈中栈顶元素的绝对索引值。这个值也是虚拟栈中的元素数量（虚拟栈的容量）。在未增减虚拟栈中的元素之前调用此函数可以得到原生函数的参数数量。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_top(bvm *vm);
\end{lstlisting}

这个函数通常用来获取原生函数的参数数量，用作此目的时，建议在原生函数体的最前面位置调用 \texttt{be\_top}。例如：
\begin{lstlisting}[language=c, style=berry, numbers=none]
static int native_function_example(bvm *vm)
{
    int argc = be_top(vm); // Get the number of arguments
    // ...
}
\end{lstlisting}

\ffititle{be\_typename}

该函数会把 Berry 对象的类型转换为字符串返回，例如对整型对象会返回 \texttt{"int"}，而函数对象会返回 \texttt{"function"}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_typename(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待操作对象的索引。Berry 标准库中的 \texttt{type} 函数就是通过调用 \texttt{be\_typename} 来实现的，参数类型对应的返回字符串请参看\ref{section::baselib_type}节。

\ffititle{be\_classname}

这个函数用于获取对象或者类的类名，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_classname(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待操作对象的索引。如果 \texttt{index} 处的值为实例，\texttt{be\_classname} 函数会返回实例所属的类名称字符串，如果 \texttt{index} 处的值为类则直接返回类名称字符串。其他情况下 \texttt{be\_classname} 会返回 \texttt{NULL}。

\ffititle{be\_strlen}

这个函数返回指定 Berry 字符串的长度，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_strlen(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待操作对象的索引。该函数返回 \texttt{index} 处字符串的字节数（Berry 字符串尾部的 \texttt{'\textbackslash 0'} 字符不计数）。如果 \texttt{index} 位置的值不是字符串，\texttt{be\_strlen} 函数会返回 \texttt{0}。

虽然 \texttt{Berry} 字符串兼容 C 的字符串格式，但是不建议使用 C 标准库的 \texttt{strlen} 函数来测量 Berry 字符串的长度。对于 Berry 字符串而言，\texttt{be\_strlen} 比 \texttt{strlen} 更快，并且兼容性更好。

\ffititle{be\_strconcat}

这个函数用于拼接两个 Berry 字符串的，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_strconcat(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针。该函数会将 \texttt{index} 参数位置的字符串与栈顶位置的字符串进行拼接，然后将所得的字符串放入 \texttt{index} 索引的位置。

\ffititle{be\_pop}

这个函数会将栈顶的值出栈，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pop(bvm *vm, int n);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{n} 为需要出栈值的数量。注意，\texttt{n} 的值不能超过栈的容量。

\ffititle{be\_remove}

这个函数会移除栈中的某个值，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_remove(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为待移除对象的索引。将 \texttt{index} 处的值移出后，后面的值会向前填充，栈的容量也会减一。\texttt{index} 的值不能超过栈的容量。

\ffititle{be\_absindex}

这个函数返回给定索引值的绝对索引值，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_absindex(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为输入索引值。如果 \texttt{index} 为正值，\texttt{be\_absindex} 的返回值就是 \texttt{index} 的值。如果 \texttt{index} 为负值，texttt{be\_absindex} 的返回值为 \texttt{index} 对应的绝对索引值。当 \texttt{index} 为负值（是相对索引）时，其索引位置不能低于栈底。

\ffititle{be\_newlist}

该函数会建立一个新的 \texttt{list} 值，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_newlist(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针。该函数成功调用后会将新的 \texttt{list} 值压入栈顶。

\ffititle{be\_newmap}

该函数会建立一个新的 \texttt{map} 值，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_newmap(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针。该函数成功调用后会将新的 \texttt{map} 值压入栈顶。

\ffititle{be\_getglobal}

该函数会将指定名字的全局变量压入栈中，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getglobal(bvm *vm, const char *name);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{name} 为全局变量的名字。该函数调用后，会将名为 \texttt{name} 的全局变量压入虚拟栈的栈顶。

\ffititle{be\_setmember}

该函数用于设置实例对象类成员变量的值，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setmember(bvm *vm, int index, const char *k);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为实例对象的索引，参数 \texttt{k} 为成员的名字。这个函数会把栈顶的值拷贝给索引位置实例的 \texttt{k} 的成员。注意栈顶元素不会自动弹出。

\ffititle{be\_getmember}

该函数用于获取实例对象类成员变量的值，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getmember(bvm *vm, int index, const char *k);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为实例对象的索引，参数 \texttt{k} 为成员的名字。这个函数会把索引位置实例的 \texttt{k} 的成员的值压入虚拟栈栈顶。

\ffititle{be\_getindex}

该函数用于获取 \texttt{list} 或者 \texttt{map} 中的一项值。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getindex(bvm *vm, int index);
\end{lstlisting}

\ffititle{be\_setindex}

该函数用于设置 \texttt{list} 或者 \texttt{map} 中的一项值。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setindex(bvm *vm, int index);
\end{lstlisting}

\ffititle{be\_getupval}

\ffititle{be\_setupval}

\ffititle{be\_getsuper}

\ffititle{be\_data\_size}

\ffititle{be\_data\_append}

\ffititle{be\_data\_insert}

\ffititle{be\_data\_remove}

\ffititle{be\_data\_resize}

\ffititle{be\_iter\_next}

\ffititle{be\_iter\_hasnext}

\ffititle{be\_refcontains}

\ffititle{be\_refpush}

\ffititle{be\_refpop}

\ffititle{be\_stack\_require}

\ffititle{be\_isnil}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{nil}，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isnil(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isbool}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{bool} 类型，如果是则函数返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isbool(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isint}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为整数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isint(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isreal}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为实数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isreal(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isnumber}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为整数或实数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isnumber(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isstring}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为字符串类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isstring(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isclosure}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为闭包类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isclosure(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isntvclos}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为原生闭包类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isntvclos(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isfunction}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为函数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isfunction(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。函数类型包括闭包、原生函数和原生闭包 3 种。

\ffititle{be\_isproto}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{proto} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isproto(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。\texttt{proto} 类型是 Berry 闭包的函数原型。

\ffititle{be\_isclass}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{class} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isclass(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isinstance}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{instance} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isinstance(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_islist}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{list} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_islist(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_ismap}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{map} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_ismap(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_iscomptr}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为通用指针类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_iscomptr(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\section{配置文件}

Berry 解释器的配置头文件为 \emph{berry\_conf.h}。此文件中包括一批用于配置的宏，并定义了一些平台相关的内容。

\subsection{配置宏}

本节介绍的配置宏通常用于某些源代码的编译开关，为了方便描述，我们把这种宏称为``宏开关''。对于宏开关而言，``打开''是指将宏开关设置为非零值，而``关闭''是指将宏开关的值设置为 \texttt{0}。

有一些宏开关具有多种状态，而不仅仅是``打开''或者``关闭''，这些宏开关一般用于有多种选择的配置。还有一些配置宏不是宏开关，无论这些宏的值是多少，都不会有代码因此不参与编译，这些宏一般用于配置数量值。

\ffititle{BE\_DEBUG} \label{section::BE_DEBUG}

这个宏开关用于开启或关闭解释器本身的调试功能，\texttt{BE\_DEBUG} 的值为 \texttt{0} 时关闭调试，否则会打开调试。此处所说的调试功能是指对解释器的调试，而不是对 Berry 程序的调试功能。\texttt{BE\_DEBUG}的默认值为 \texttt{0}。如果你使用解释器项目自带的 \emph{Makefile} 来编译，使用 \texttt{make debug} 命令时会自动打开这个宏开关。

打开这个宏时会开启一些断言，当解释器出现断言可以捕获的错误时将会输出错误信息。在调试解释器的时候可以打开 \texttt{BE\_DEBUG}，编译发行版时则要关闭它。

\ffititle{BE\_SINGLE\_FLOAT}

这个宏开关配置 \texttt{breal} 类型使用的浮点类型。当宏的值为 \texttt{0} 时将使用 \texttt{double} 类型来实现 \texttt{breal}，否则使用 \texttt{float} 类型实现 \texttt{breal}。在一些对性能或内存配置较低的环境中可以打开这个宏开关，默认实现中这个宏开关是关闭的。

\ffititle{BE\_RUNTIME\_DEBUG\_INFO}

这个宏用于配置 Berry 代码的运行时调试信息。它有 3 个可用的值：设置为 \texttt{0} 会关闭运行时调试信息的文件名和行号输出，设置为 \texttt{1} 时会在运行时调试信息中输出文件名和行号，设置为 \texttt{2} 时将使用 \texttt{uint16\_t}（16 位整数）类型存储行号信息。它的默认值为 \texttt{1}。

将这个宏设置为 \texttt{0} 时不会因为存储文件名和行号信息，因此内存消耗最少。设置为 \texttt{2} 时消耗的内存也比较少，但是程序太长会使 \texttt{uint16\_t} 溢出。

\ffititle{BE\_USE\_PRECOMPILED\_OBJECT}

这个宏开关配置原生对象是否要在编译期生成。打开这个宏时，标准库中的原生对象将在编译期生成，而不是在运行时动态地构建。关闭这个宏会在运行时构建标准库中的对象。这个宏默认打开。

编译期生成的对象和代码存放在一起，不会占用 RAM （或是内存中可读写的区域）资源，编译期生成对象还能减少解释器的启动时间，因此建议打开这个宏。

\ffititle{BE\_STACK\_TOTAL\_MAX}

这个宏定义了最大的 Berry 堆栈容量，该容量是指 Berry 对象的数量。当 Berry 代码使用了超过此数量的堆栈时将会停止执行程序并返回错误信息。这个宏的默认值是 \texttt{200}，可以根据系统的内存容量修改这个值。

这个值不会影响 Berry 堆栈的内存使用量，因为 Berry 堆栈的容量是动态调节的，因此无论将它设置为多少都不能帮助减少内存使用。它的主要作用是在 Berry 程序因为消耗过多的堆栈时终止执行。这些程序很有可能是不正确的，例如没有返回条件的递归函数调用就会不断地消耗堆栈。

\ffititle{BE\_STACK\_FREE\_MIN}

这个宏定义了 Berry 堆栈最少的可用空间，其默认值为 \texttt{10}。原生函数可能会往 Berry 堆栈中压入值，此时堆栈不会自动增长，因此要保证堆栈中有足够的空位供原生函数使用。不建议修改这个值，而是在确实需要更多的栈空间的位置使用 \texttt{be\_stack\_require} 函数。

为了在调试解释器时检测栈溢出错误，可以打开 \texttt{BE\_DEBUG} 宏（\ref{section::BE_DEBUG}节）。

\ffititle{BE\_USE\_STRING\_MODULE}

这个宏开关用于启用或关闭 \texttt{string} 模块，默认打开。

\ffititle{BE\_USE\_JSON\_MODULE}

这个宏开关用于启用或关闭 \texttt{json} 模块，默认打开。

\ffititle{BE\_USE\_MATH\_MODULE}

这个宏开关用于启用或关闭 \texttt{math} 模块，默认打开。

\ffititle{BE\_USE\_TIME\_MODULE}

这个宏开关用于启用或关闭 \texttt{time} 模块，默认打开。

\ffititle{BE\_USE\_OS\_MODULE}

这个宏开关用于启用或关闭 \texttt{os} 模块，默认打开。注意， \texttt{os} 模块目前只能在支持 POSIX 标准的环境中编译。

\subsection{函数定义}

配置文件中的一些宏用于定义平台相关的函数，默认的实现中使用 C 标准库中的函数来填充这些宏。在移植 Berry 解释器时可能需要修改这些宏。

\ffititle{be\_assert}

\ffititle{be\_fhandle}

\ffititle{be\_fopen}

\ffititle{be\_fclose}

\ffititle{be\_fwrite}

\ffititle{be\_fread}

\ffititle{be\_fgets}

\ffititle{be\_fseek}

\ffititle{be\_ftell}

\ffititle{be\_fflush}

\section{模块}

这个功能还不完善。

\section{编译期 Hash 技术}

这部分功能还没有完成。

\subsection{编译期字符串表}

\subsection{编译期构造类}

\subsection{编译期构造模块}
