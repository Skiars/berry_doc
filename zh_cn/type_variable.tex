\chapter{类型和变量}

\textbf{类型}是数据的一种属性，它定义了数据的含义以及可以对数据执行的操作。Berry中的类型主要分为类类型和简单类型（整数、浮点数、字符串等）。而类提供了用户自定义类型的机制，且类类型比简单类型提供更复杂的操作。

\section{内建类型}

Berry内置了一些简单类型或者类类型，这些类型被称为内建类型。所有可以使用字面值来表示的数据类型都属于内建类型。内建类型也是十分常用的类型。

\subsection{Nil}

Nil类型即空类型，它表示对象具有一个无效值，也可以说对象没有有意义的值。这是一个十分特殊的类型，尽管我们可能会说一个变量为\texttt{nil}，但实际上nil类型没有值，因此这里说的其实是该变量的类型为nil（而不是值）。

一个变量在赋值之前的默认值就是\texttt{nil}。该类型可以用于逻辑运算，在逻辑运算中，\texttt{nil}等价于\texttt{false}。

\subsection{整数类型}

整数类型（integer）表示有符号的整数，简称整数。该类型所表示的整数的比特位数取决于具体实现，在32位平台中通常由32位的有符号整数。整数是一种算术类型并支持所有的算术运算。在使用该类型时要注意整数的取值范围，典型的32位有符号整数取值范围是$-2147483648$到$2147483647$之间。

\subsection{实数类型}

实数类型（real），准确地说是浮点类型。实数类型通常实现为单精度浮点数或者双精度浮点数。实数类型也是一种算术类型。相比于整数类型，实数类型有更高的精度和更大的取值范围，因此该类型更适用于数学计算。需要注意的是，实数类型实际上是浮点数，因此还是存在精度问题，例如将两个\texttt{real}类型的数值进行相等比较是不推荐的。

整数和实数同时参与运算时通常会将整数转换为实数。

\subsection{布尔类型} \label{section:type_bool}

布尔类型（boolean）用于逻辑运算，其具有两个值\texttt{true}和\texttt{false}，表示逻辑和布尔代数中的两个真值（真和假）。布尔类型主要用于条件判断。逻辑表达式和关系表达式的操作数以及返回值都是布尔类型，而且\texttt{if}、\texttt{while}等语句都使用布尔类型作为条件检测。

很多时候非布尔值也可以当作布尔类型去使用，这是因为解释器会对参数进行隐式类型转换。这也是诸如\texttt{if}语句的条件检测表达式可以使用任何类型参数的原因。各种类型到布尔类型转换的规则为：
\begin{itemize}
    \item Nil：转换为\texttt{false}。
    \item 整数：值为\texttt{0}时转换为\texttt{false}，否则转换为\texttt{true}。
    \item 实数：值为\texttt{0.0}时转换为\texttt{false}，否则转换为\texttt{true}。
    \item 实例：存在方法\texttt{tobool()}时将使用该方法的返回值，否则转换为\texttt{true}。
    \item 其他：转换为\texttt{true}。
\end{itemize}

\subsection{字符串}

一个字符串（string）是由字符构成的序列。从存储上来讲，Berry把字符串分为长字符串和短字符串两种。相同的短字符串在内存中只有一个实例，并且所有的短字符串链接在一个哈希表中，这种设计有利于提高字符串相等比较的性能，并且可以减少内存使用。由于长字符串的使用频率较低，而哈希运算的开销却不少，因此没有将它们链接到哈希表中，，故内存中可能有多个相同的实例。字符串在创建之后是只读的，因此，对字符串进行``修改''将会产生新的字符串，而原来的字符串不会被修改。

Berry并不关心字符的格式或者编码，例如字符串\texttt{'abc'}实际上就是字符\texttt{'a'}，\texttt{'b'}和\texttt{'c'}的ASCII码排列而成。因此，若字符串中存在宽字符（字符长度大于1字节）则无法直接统计字符串中字符的个数，使用\texttt{length()}函数实际上只能得到字符串的字节数。另外，为了方便和C语言交互，Berry的字符串总是以\texttt{'\textbackslash 0'}字符结束，这个特性对于Berry程序来说是透明的。

字符串类型可以比较大小，因此可以用于关系运算。

\subsection{函数}

函数（function）是一段具有名字的代码，它一般用于实现特定的功能。在Berry中函数实际上是一个大类，包括闭包、原生函数、原生闭包等几个子类型。不过，函数的所有子类型都有相同的操作，因此我们不需要关心``函数''具体是什么子类型。函数也是非常常用的类型，为了代码可以重复利用，我们通常把具有特定功能的对端代码做成一个函数，然后通过``函数调用''来运行这一段代码。

而函数本身可以当成一个只读的对象，而这种对象的类型就是``函数''。这意味着可以把函数赋值给一个变量并通过变量来调用。

函数类型只能比较等于和不等，而不能比较大小。

\subsection{类}

在面向对象的编程中，类（class）是一个可扩展的程序代码模板。类用于创建实例对象，因此类可以说是实例的``类型''。所有的实例对象其类型都是\texttt{instance}，同时它们都有一个对应的类，这个类叫做实例的\textbf{类类型}。简单点说，一个类是表示实例对象类型的值，类是对实例特征的抽象。类也是一种只读对象，一旦定义就不能再被修改。

类只能比较等于和不等，而不能比较大小。

\subsection{实例}

实例（instance）是通过类生成的具体化对象，由类生成实例的过程称为\texttt{实例化}。在面向对象编程中，``实例''通常和``对象''同义。不过为了和非实例对象区分，我们不单独使用``对象''一词，而是使用``实例''或者``实例对象''。Berry的实例总是动态分配的，需要搭配垃圾回收器来使用。除了内存分配，实例化的的过程还需要对实例进行初始化，这个过程由\texttt{构造函数}来完成。此外还可以在回收对象的内存之前通过\texttt{析构函数}完成对象的销毁。

在内部实现中，实例会包含对类的引用，实例本身只存储成员变量而不存储方法。

\subsection{List}

List是一个类，它是对可变数组的封装，用于提供线性表数据结构。List中存储的元素可以是任意类型，可以使用索引或者迭代器来访问list中的元素。该类型还提供\texttt{append}、\texttt{insert}等方法。

\subsection{Map}

用于存储键值对。值可以是任何类型。

\subsection{Range}

表示一个整数区间。通常用于范围迭代。

\section{变量}

变量（variable）是具有名字的存储空间，该存储空间存储的数据或信息称为变量的值。变量名用于在源代码中引用变量。在不同的作用域中，一个变量名可以绑定多个独立变量，但是变量则没有别名。变量的值可以在程序运行过程中随时访问或更改。Berry是一种动态类型语言，因此变量值的类型是在运行时确定的，且变量可以存储任意类型的值。

\subsection{定义变量}

第一种定义变量的方法是使用赋值语句将一个值赋给新的变量名：
\begin{algorithm}
$\bm{variable}$\texttt{ = }$\bm{expression}$
\end{algorithm}\vspace{-0.6em}\\
$\bm{variable}$为变量的名字，变量名是一个标识符（见\ref{section:identifier}节）。$\bm{expression}$是初始化该变量的表达式。
\begin{lstlisting}[language=berry, numbers=none]
a = 1    b = 'str'
\end{lstlisting}
然而这种定义变量的方法存在一些局限，以下面的代码为例：
\begin{lstlisting}[language=berry]
i = 0
do
    i = 1
    print(i)  # 1
end
print(i)      # 1
\end{lstlisting}
这个例程中有一个使用\texttt{do}语句构成的内层作用域，我们在第3行的位置修改了变量\texttt{i}的值，在第6行离开内层作用域之后，\texttt{i}的值还是\texttt{1}。然而，如果我们希望内层作用域中使用的同名变量\texttt{i}是一个独立的变量，使用直接赋值给新变量名来定义变量的方法就不能使用了，因为标识符\texttt{i}已经存在于外层作用域。另一种定义变量的方法是使用\texttt{var}关键字来定义变量：
\begin{algorithm}
\texttt{var }$\bm{variable}$ \\
\texttt{var }$\bm{variable}$\texttt{ = }$\bm{expression}$
\end{algorithm}\vspace{-0.6em}\\
第一种写法是在\texttt{var}关键字后面跟随变量的名字$\bm{variable}$，此时变量会被初始化为\texttt{nil}，另一种写法是在定义变量的同时初始化变量，此时需要提供初始值表达式$\bm{expression}$。使用\texttt{var}定义变量有两种可能的结果：如果当前的作用域没有定义$\bm{variable}$的变量则定义并初始化该变量，否则相当于重新初始化该变量。

现在我们将前面的例子改用\texttt{var}关键字来定义变量：
\begin{lstlisting}[language=berry]
i = 0
do
    var i = 1
    print(i)  # 1
end
print(i)      # 0
\end{lstlisting}
从修改后的例程可以发现，变量\texttt{i}在内层作用域中的值是\texttt{1}，而它在外层作用域中的值为\texttt{0}。这证明使用\texttt{var}关键字之后在内层作用域中定义了新的变量\texttt{i}，并且屏蔽了外层作用域中的同名变量。内层作用域结束后，标识符\texttt{i}再一次和外层作用域中的变量\texttt{i}绑定。

使用\texttt{var}关键字定义变量时还可以使用多个变量名构成的列表，变量名之间使用逗号分隔。定义变量时还可以为一个或多个变量进行初始化：
\begin{lstlisting}[language=berry, numbers=none]
var a = 0, b, c = 'test'
\end{lstlisting}

\subsection{生命周期}
