\chapter{语句}

Berry是一种命令式编程语言，即程序式一步一步地执行的。通常情况下，Berry语句是顺序执行的，这种程序结构称为顺序结构。尽管顺序结构非常基础，但是实际的程序中通常还需要用到分支结构和循环结构，Berry提供几种控制语句来实现这种复杂的流程结构，例如条件语句和迭代语句。

\section{简单语句}

Berry中的语句可以以分号结束，但是大多数时候都不需要，解释器通常能自动切分语句，但是在一些不使用分号会导致歧义地方应该加上分号或者重构代码。

\subsection{表达式语句}
表达式语句主要是赋值表达式和函数调用语句。其他类型的表达式也可以构成一个语句，但是不会有什么意义，例如表达式\texttt{1+2}就可以是一条语句，但是它不能对其它代码产生任何影响，因此没有实际作用。而表达式\texttt{a=2}则将常量\texttt{2}赋值给了一个变量\texttt{a}，从而影响了该变量在上下文中的行为。下面我们给出一个表达式语句和函数语句的例子：
\begin{lstlisting}[language=berry, numbers=none]
a = 1       # assignment statement
print(a)    # call statement
\end{lstlisting}

实际上，除了行注释以外，回车或换行符（``\texttt{\textbackslash r}''和``\texttt{\textbackslash n}''）仅作为空白字符使用，因此一条语句可以是多行的。多行的表达式和单行表达式写法相同，不需要使用专门的续行符号。但是有些时候，解释器可能把本意是两条语句的代码解释成一条语句：
\begin{lstlisting}[language=berry]
a = 1 +
    func()      # wrap line
b = 1 c = 2     # multiple statements
a = c
(b) = 1         # be regarded as a function call
\end{lstlisting}
这些代码中，第1行和第2行是一个多行表达式语句，第3行有两个表达式语句。第4行和第5行本意是两条表达式语句\texttt{a = c}和\texttt{(b) = 1}，但是解释器会把它们理解成一条语句：\texttt{a = c(b) = 1}，这和我们的本意是相违背的。

这个问题有以下几种解决方案：
\begin{itemize}
    \item 不要在赋值号的左侧使用括号，而且只使用简单的表达式。
    \item 使用符号``\texttt{;}''来显式地分隔语句。
\end{itemize}

\subsection{块}

一个块（Block）是若干语句的集合。一个块就是一个作用域，在块中定义的变量只能在块及其子块内部访问。有很多地方需要使用到块，例如：\texttt{if}语句、\texttt{while}语句、函数声明等。这些要使用块的语句都使用一对关键字来包含一个块。例如在\texttt{if}语句中使用的块：
\begin{lstlisting}[language=berry]
if (isOpen)
    close()
    print('the device was closed')
end
\end{lstlisting}
第2行到第3行的语句构成了一个块，这个块夹在\texttt{if}和\texttt{end}这一对关键字中间（\texttt{if}语句的条件表达式不算）。块可以不包含任何语句，这样就构成一个空的块，也可以说是包含一条空语句的块。

\subsubsection{\texttt{do}语句}

有时候我们仅仅想开辟一个新的作用域，但是又不想使用任何控制语句，这种情况下可以使用\texttt{do}语句来封装块。\texttt{do}语句没有任何控制功能。\texttt{do}语句的形式为
\begin{algorithm}
    \texttt{do}\\
    \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}
其中$\bm{block}$就是我们需要的块。该语句使用一对\texttt{do}和\texttt{end}关键字来包含块，并且没有任何控制功能，也不会生成任何运行时的指令。

\section{条件语句}

Berry提供\texttt{if}语句来实现条件控制执行的功能。\texttt{if}语句会根据条件表达式的真（\texttt{true}）或假（\texttt{false}）来控制程序执行的分支。在一些语言中，实现条件控制还有其他的选择，例如C、C++等语言提供\texttt{switch}语句，不过为了简化设计，Berry没有支持\texttt{switch}语句。

\subsection{\texttt{if}语句}

\textbf{\texttt{if}语句}可以用来实现简单的分支结构，它根据某种判断条件的真假来选择程序运行的分支。\texttt{if}语句的形式为
\begin{algorithm}
    \texttt{if (} $\bm{condition}$ \texttt{)} \\
    \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}

$\bm{condition}$是条件表达式，当$\bm{condition}$的值为\texttt{true}时，将会执行第二行的$\bm{block}$，否则会跳过该$\bm{block}$并执行\texttt{end}后面的语句。在$\bm{block}$被执行的情况下，块中的最后一条语句执行完以后会离开\texttt{if}语句并开始执行\texttt{end}后面的语句。

如果希望条件满足和不满足时都有对应的分支可供执行则需要使用\textbf{\texttt{if else}语句}。该语句的形式为
\begin{algorithm}
    \texttt{if (} $\bm{condition}$ \texttt{)} \\
        \qquad $\bm{block}$ \\
    \texttt{else} \\
        \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}

与简单的\texttt{if}语句不同的是，\texttt{if else}语句在$\bm{condition}$的值为\texttt{false}时将会执行\texttt{else}分支下的$\bm{block}$。无论哪个分支的$\bm{block}$被执行，在其执行完以后都会跳出\texttt{if else}语句——执行\texttt{end}后面的语句，也就是说，无论$\bm{condition}$的值是\texttt{true}还是\texttt{false}，都只有一个$\bm{block}$被执行。

有时候我们需要嵌套使用\texttt{if}语句，一种情况是要在\texttt{else}分支下嵌套一个\texttt{if}语句：
\begin{lstlisting}[language=berry, numbers=none]
if (expr)
    block
else
    if (expr)
        block
    end
end
\end{lstlisting}
很明显，这种写法会增加代码的缩进层次，并且结尾处要使用多个\texttt{end}，比较繁琐。作为改进，Berry提供了\texttt{elif}分支来优化上面的写法。使用\texttt{elif}分支与上述代码等价，其形式为
\begin{algorithm}
    \texttt{if (} $\bm{condition}$ \texttt{)} \\
        \qquad $\bm{block}$ \\
    \texttt{elif (} $\bm{condition}$ \texttt{)} \\
        \qquad $\bm{block}$ \\
    \texttt{else} \\
    \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}

\texttt{elif}分支必须用在\texttt{if}分支之后并可以连续使用多次。如果\texttt{elif}分支对应的$\bm{condition}$满足则会执行分支下的$\bm{block}$。

\section{迭代语句}

迭代语句又叫循环语句，用于重复执行某种操作直到终止条件满足。Berry提供\texttt{while}语句和\texttt{for}两种迭代语句。很多语言也是提供这两种语句用于迭代。Berry的\texttt{while}语句和C/C++中的\texttt{while}语句类似，而Berry的\texttt{for}语句仅用于遍历容器中的元素，类似一些语言提供的\texttt{foreach}语句，以及C++ 11引入的新\texttt{for}语句风格。而C风格的\texttt{for}语句在Berry中则没有实现。

\subsection{\texttt{while}语句}

\textbf{\texttt{while}语句}是一种基本的迭代语句，\texttt{while}语句根据一个判断条件来进入循环并在条件不满足时终止循环，其模式为
\begin{algorithm}
    \texttt{while (} $\bm{condition}$ \texttt{)} \\
        \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}

程序运行到\texttt{while}语句时会检测$\bm{condition}$表达式的真假，如果为真则执行$\bm{block}$。执行完$\bm{block}$中的最后一条语句后，程序会跳转到\texttt{while}语句的开始位置并重新检测$\bm{condition}$的真假，为真则开始下一轮的循环。当$\bm{condition}$表达式为假时\texttt{while}语句将会终止，此时会继续执行\texttt{end}后的第一条语句。显然，如果$\bm{condition}$表达式在第一次判断时为假则不会执行$\bm{block}$（和\texttt{if}语句的$\bm{condition}$表达式为假时一样）。

\subsection{\texttt{for}语句}

Berry的\textbf{\texttt{for}语句}用于遍历容器中的元素，其形式为
\begin{algorithm}
    \texttt{for (} $\bm{varaible}$ \texttt{:} $\bm{expression}$ \texttt{)} \\
        \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}

$\bm{expression}$表达式的值必须是一个可迭代的容器，例如\texttt{range}类。\texttt{for}语句会从容器中获取一个迭代器，通过对调用迭代器的调用实现每次循环得到容器中的一个元素。

$\bm{varaible}$称为迭代变量，迭代变量总是在\texttt{for}语句中定义。因此$\bm{varaible}$必须是一个变量名而不能是表达式。每次循环时从迭代器中获取的容器元素将会赋值给迭代变量，该过程发生在$\bm{block}$的第一条语句之前。

\texttt{for}语句会检查迭代器中是否还有未访问的元素可供迭代，如果有则开始下一轮的迭代，否则会结束\texttt{for}语句并执行\texttt{end}后面的语句。目前，Berry只提供只读迭代器，也就是说无法通过\texttt{for}语句中的迭代变量来修改容器中的元素。

迭代变量$\bm{varaible}$的作用域仅限于循环体$\bm{block}$中，该变量不会和作用域外的同名变量有任何关系。为了说明这一点，我们通过一个例子来说明，在这个例子里，我们使用\texttt{for}语句来访问\texttt{rang}实例中的所有元素并打印出来。当然，我们还通过这个例子来演示循环变量的作用域。
\begin{lstlisting}[language=berry]
i = "Hi, I'm fine." # outer variable
for (i : 0 .. 2)
    print(i)        # iteration variable
end
print(i)
\end{lstlisting}

在这个例子中，相对于第2行定义的的迭代变量\texttt{i}而言，第1行定义的变量\texttt{i}为外部变量。运行这个例子将得到下面的结果
\begin{lstlisting}[numbers=none]
0
1
2
Hi, I'm fine
\end{lstlisting}
可以看出，迭代变量\texttt{i}和外部变量\texttt{i}是两个不同的变量，它们只是名字相同，但是作用域不同。

\section{跳转语句}

Berry提供的的跳转语句用于在循环过程中实现程序流程的跳转。跳转语句分为\texttt{break}语句和\texttt{continue}语句，这两种语句必须在迭代语句内部使用，并且只能在函数内部实现跳转。有些语言提供\texttt{goto}语句来实现函数内部的任意跳转，这种语句Berry不提供，不过\texttt{goto}语句的效果完全可以用条件语句和迭代语句来代替。

\subsection{\texttt{break}语句}

\texttt{break}用来终止迭代语句并跳出。执行\texttt{break}语句之后将立即终止最近一层迭代语句并从该迭代语句后的第一条语句位置继续执行。为了说明\texttt{break}语句的执行流程，我们使用一个例子来演示：
\begin{lstlisting}[language=berry]
while (true)
    print('before break')
    break
    print('after break')
end
print('out of the loop')
\end{lstlisting}
在这段代码中，\texttt{break}语句处于一个\texttt{while}循环中，在\texttt{break}语句前后和\texttt{while}语句后面我们各放置了一条打印语句来测试程程序的执行流程。这段代码的运行结果为：
\begin{lstlisting}[numbers=none]
before break
out of the loop
\end{lstlisting}
这说明\texttt{while}语句在第3行的\texttt{break}语句位置结束了循环并使程序从第6行继续执行。

\subsection{\texttt{continue}语句}

\texttt{continue}语句也在迭代语句内部使用，它的作用是结束一次迭代并立即开始下一轮。因此，执行\texttt{continue}语句之后，最近一层的迭代语句中的剩余代码将不再执行，而是开始新一轮迭代。这里我们使用一个\texttt{for}语句来演示\texttt{continue}语句的功能：
\begin{lstlisting}[language=berry]
for (i : 0 .. 5)
    if (i >= 2)
        continue
    end
    print('i =', i)
end
print('out of the loop')
\end{lstlisting}
这里的\texttt{for}语句将会迭代6次，当迭代变量\texttt{i}大于等于\texttt{2}以后将会执行第3行的\texttt{continue}语句，此后第5行的打印语句将不会执行。也就是说第5行只会在前两轮迭代中执行（此时\texttt{i<2}）。该例程的运行结果为：
\begin{lstlisting}[numbers=none]
i = 0
i = 1
out of the loop
\end{lstlisting}
可以看出变量\texttt{i}的值只打印了2次，符合预期。读者可以尝试在\texttt{continue}语句之前打印变量\texttt{i}的值，你会发现\texttt{for}语句确实迭代了6次，说明\texttt{continue}语句并不会终止迭代。
