\chapter{函数}

函数是Berry的基本功能之一，一个函数是一段有名字的代码，一个函数可以用于执行一些特定功能。函数具有自己的变量环境，但是也能访问外部的变量。本章将介绍Berry中关于函数的细节。

\section{定义函数}

\subsection{函数声明}

定义函数的过程称为\textbf{函数声明}。函数声明使用关键字\texttt{def}来开始，其形式为
\begin{algorithm}
    \texttt{def} $\bm{name}$ \texttt{(} $\bm{arguments}$ \texttt{)} \\
        \qquad $\bm{block}$ \\
    \texttt{end}
\end{algorithm}\vspace{-0.6em}\\
函数声明有3个主要的部分：函数名称$\bm{name}$、函数参数列表$\bm{arguments}$和函数体（Function Body）$\bm{block}$。函数参数列表和函数体可以为空。函数名称实际上就是一个变量名称，也就是一个标识符，Berry不支持匿名函数，因此函数名称是必须的。函数的参数列表是一个变量名列表，这些变量用于存储函数的输入参数，多个参数之间使用逗号分隔。函数体是实现函数功能的Berry语句集合，也就是一个块。函数参数列表和函数体可以为空。

来看一个简单的例子，我们定义了一个\texttt{add}函数来输出两个数的和：
\begin{lstlisting}[language=berry, numbers=none]
def add(a, b)
    return a + b
end
\end{lstlisting}

函数\texttt{add}使用了两个参数\texttt{a}和\texttt{b}，这个函数使用一个\texttt{return}语句将\texttt{a}和\texttt{b}的值返回。

Berry不支持匿名函数，但是由于函数名实际上是一个变量，并且该变量的作用域包含函数内部。你可以使用这个特性来将函数名赋值给其他变量并调用：
\begin{lstlisting}[language=berry, numbers=none]
def square(n)
    return n * n
end
f = square
print(f(5))     # 25
\end{lstlisting}
还可以定义递归函数，递归函数即是在函数中调用函数本身的函数，下面是一个递归计算斐波那契数列的函数：
\begin{lstlisting}[language=berry, numbers=none]
def fib(n)
    if (n < 2)
        return 1
    end
    return fib(n - 2) + fib(n - 1)
end
\end{lstlisting}
当然，这是一个教科书级的糟糕递归示例，该函数将运行地十分缓慢。这里我们只是演示一下递归的使用，而不去深入递归的知识。

在Berry中，函数总是由一个变量来引用，而函数定义则是在定义函数名的同时初始化该变量。你可以在同级作用域内重复定义同名的函数，此时使用函数名只能调用最后定义的变量，当然，你还可以直接将一个值赋给函数名，就像其他的变量赋值一样。

函数可能是对象（类或者实例）的属性，此时的函数称为方法，这部分内容会在面向对象章节中说明。

\subsection{函数参数传递}

函数的参数传递分为传值和传引用两种情况。


\subsection{函数作用域}

每个函数都有自己的变量环境，假设主调函数和被调函数都有一个变量``\texttt{a}''（变量在函数中的相对位置相同），但它们的值并不会互相影响，这是由于两个函数使用不同的``堆栈''空间。在函数中定义的变量仅在函数内部可访问，当然，在函数内部定义的函数可以访问父函数中定义的变量。

\subsection{\texttt{return}语句}

\texttt{return}语句用于返回函数的结果，也就是返回值。Berry中的所有函数都具有返回值，但是你可以在函数体中不使用任何\texttt{return}语句，此时解释器会生成一条默认的\texttt{return}语句以保证函数的返回。\texttt{return}语句有两种写法：
\begin{algorithm}
    \texttt{return} \\
    \texttt{return }$\bm{expression}$
\end{algorithm}\vspace{-0.6em}\\
第一种写法是只写出一个\texttt{return}关键字，这种写法返回一个\texttt{nil}值，第二种写法是\texttt{return}关键字后面跟随表达式$\bm{expression}$，这种写法会返回$\bm{expression}$的值。当程序执行到\texttt{return}语句时，当前运行的函数会立即停止执行并返回到调用该函数的代码中继续运行。

当使用单独的关键字\texttt{return}作为函数的返回语句时，容易引起二义性的问题，此时建议在\texttt{return}后面加分号来防止出现错误：
\begin{lstlisting}[language=berry, numbers=none]
def func()
    return;
    x = 1
end
\end{lstlisting}

\section{函数调用}

函数定义实质上是将一段代码封装起来，但不会立即运行。要想执行函数中的代码，必须使用\textbf{函数调用}来实现。函数调用会赋予一个函数真正的参数并运行函数，最后使用函数的返回值。

函数的调用必须位于函数名的作用域内，因此函数调用必须位于函数定义之后，且必须是同级或更深层的作用域。Berry不能前向调用，这多少有些不方便，为了解决这个问题可以使用这种方法来折衷：
\begin{lstlisting}[language=berry, numbers=none]
var func1
def func2(x)
    return func1(x)
end
def func1(x)
    return x * x
end
print(func1(4))     # 16
\end{lstlisting}
这种写法可以在一定程度上解决前向调用的的问题，但并不优雅。

\section{嵌套函数和闭包}

你可以在一个函数中定义另一个嵌套函数。嵌套函数可以访问任何层级外层函数的局部变量，但是外层函数不能访问嵌套函数的局部变量，因为函数的局部变量作用域仅在函数内部。可以说嵌套函数的局部变量是它的私有成员，此时嵌套函数就构成了一个闭包。一个闭包是一个具有独立环境与变量的表达式（在Berry中是函数）。

闭包可以使用外层函数的变量，即内部函数包含外层函数的作用域。如果在闭包中使用了外层函数中的局部变量则称这些变量为自由变量。由于外层函数可能先于闭包返回，因此闭包必须保存自由变量的环境以保证该变量可以被闭包正确访问直到闭包销毁。
