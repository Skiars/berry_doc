\chapter{表达式}

\section{基础}

一个表达式（Statement）由一个到多个操作数和运算符组成，通过对表达式求值可以得到一个结果，这个结果被称为表达式的值。操作数可以是一个字面值、变量、函数调用或者是子表达式等。使用简单的表达式和运算符也可以组合成较为复杂的表达式。与四则运算类似，运算符的优先级会影响表达式的求值顺序，优先级越高的运算符，其表达式越先求值。

\subsection{运算符和表达式}

Berry提供一些一元运算符（Unary Operator）和二元运算符（Binary Operator）。例如逻辑与运算符\texttt{\&\&}就是一个二元运算符，而逻辑非运算符\texttt{!}是一个一元运算符。一些运算符既可以是一元运算符也可以是二元运算符，这种运算符的具体含义要通过上下文来决定。例如运算符\texttt{-}在表达式\texttt{-1}中是一元符号，但是在表达式\texttt{1-2}中则是二元的减号。

\subsubsection{运算符组合表达式}

二元运算符左右两边都可以是子表达式，因此可以使用二元运算符来组合表达式。一个较为复杂的表达式往往具有多种运算符和操作数。这时候，表达式中各个子表达式的求值顺序（order of evaluation）可能会影响到表达式的值。而运算符的优先级（precedence）和结合性（associativity）保证了表达式求值顺序的唯一性。例如一个组合表达式：
\begin{lstlisting}[language=berry, numbers=none]
1 + 10 / 2 * 3
\end{lstlisting}
日常使用的四则运算会先计算除法表达式\texttt{10/2}，然后计算乘法表达式，最后计算加法表达式。这是因为乘法和除法比加法具有更高的优先级。

\subsubsection{操作数类型}

在表达式的运算中，操作数可能和运算符具有不匹配的类型，另外二元运算符通常要求左右操作数是同一种类型。表达式\texttt{'10'+10}是错误的，你无法对一个字符串和一个整数做加法，而表达式\texttt{-'b'}的问题是不能对字符串取负值。有时候二元运算符两边的操作数类型不同但是却可以执行运算，例如将一个整数和一个实数相加时，整数对象会被转换为实数并与另一个实数对象相加。而逻辑与和逻辑或运算符允许运算符两边的操作数为任意类型，在逻辑表达式中它们总是会按照一定的规则转换为\texttt{boolean}类型。

另外一种情况是使用自定义类的时候可以重载运算符。本质上来说你可以任意解释这个运算符，那么它的操作数应该是什么类型也是由你决定了。

\subsection{优先级和结合性}

在使用多个运算符组合而成的复合表达式中，运算符的优先级和结合性决定了表达式的求值顺序。各个运算符的优先级和结合性在表\ref{tab::operator_list}中给出。

优先级指定了不同运算符之间的求值顺序，具有高优先级运算符的表达式会先被求值。例如，对表达式\texttt{1+2*3}的求值过程会先计算\texttt{2*3}的结果，然后计算加法表达式的结果。使用括号可以提升低优先级表达式的求值顺序，例如在表达式\texttt{(1+2)*3}求值中，先计算括号中表达式\texttt{1+2}的结果，然后计算括号外的乘法表达式。

结合性是指运算符两侧操作数的求值顺序，这里的操作数可能是子表达式。例如，在加法表达式\texttt{expr1 + expr2}中，先计算\texttt{expr1}的值再计算\texttt{expr2}的值，这是因为加法运算符是左结合的。

\begin{table}[htb]
    \centering
    \setlength{\tabcolsep}{4mm}
    \begin{tabular}{cclc} \Xhline{1pt}
        \makecell[c]{\textbf{优先级}} & \makecell[c]{\textbf{运算符}} & \makecell[c]{\textbf{说明}} & \makecell[c]{\textbf{结合性}} \\ \Xhline{1pt}
        1 & \texttt{()} & 分组符号 & - \\
        2 & \texttt{() [] .} & 函数调用，下标运算，域运算 & 左 \\
        3 & \texttt{+ - !} & 正号，负号，逻辑非 & 左 \\
        4 & \texttt{* / \%} & 乘法，除法，取余数 & 左 \\
        5 & \texttt{+ -} & 加法，减法 & 左 \\
        6 & \texttt{..} & 范围运算符 & 左 \\
        7 & \texttt{< <= == != > >=} & 关系运算符 & 左 \\
        8 & \texttt{\&\&} & 逻辑与 & 左 \\
        9 & \texttt{||} & 逻辑或 & 左 \\
        10 & \texttt{=} & 赋值 & 右 \\
        \Xhline{1pt}
    \end{tabular}
    \caption{运算符列表}
    \label{tab::operator_list}
\end{table}

\subsubsection{使用括号提升优先级}

当我们需要低优先级较低的运算符先求值时可以使用括号。表达式求值过程中会先计算括号中表达式的值。也就是说，对于整个表达式来说，括号中的表达式相当于一个操作数，而不管括号中的表达式的构成。

\section{算术运算符}

算术运算符用于实现算术运算，这些运算符和我们平时使用的数学符号相似。Berry提供的算术运算符如表\ref{tab::arthmetic_operator}所示。

\begin{table}[htb]
    \centering
    \setlength{\tabcolsep}{10mm}
    \begin{tabular}{ccc} \Xhline{1pt}
        \makecell[c]{\textbf{运算符}} & \makecell[c]{\textbf{功能}} & \makecell[c]{\textbf{示例}} \\ \Xhline{1pt}
        \texttt{+} & 一元正号 & \texttt{+ expr} \\
        \texttt{-} & 一元负号 & \texttt{- expr} \\
        \texttt{+} & 加号 & \texttt{expr + expr} \\
        \texttt{-} & 减号 & \texttt{expr - expr} \\
        \texttt{*} & 乘号 & \texttt{expr * expr} \\
        \texttt{/} & 除号 & \texttt{expr / expr} \\
        \texttt{\%} & 取余数 & \texttt{expr \% expr} \\
        \Xhline{1pt}
    \end{tabular}
    \caption{算术运算符}
    \label{tab::arthmetic_operator}
\end{table}

对于二元运算符\texttt{+}，当操作数为字符串时会执行字符串连接，即把两个字符串连接成一条更长的字符串，其他时候通常用作加法运算符。除了\texttt{\%}运算符以外，其他算数运算符都支持整数和实数操作数，\texttt{\%}运算符只支持整数操作数。\texttt{\%}运算符的作用是计算一个整数整数另一个整数之后的余数，例如\texttt{11\%4}的结果是\texttt{3}。

所有的算数运算符都可以在类中重载，重载后的运算符不一定局限于它们原本的功能设计，而是由程序员自己决定。

正号\texttt{+}实际上没有任何作用。它可能在将来的版本中被移除,因此不建议使用。

\section{关系运算符}

关系运算符用于比较操作数的大小关系。Berry支持的6种关系运算符在表\ref{tab::relop_operator}中给出。

\begin{table}[htb]
    \centering
    \setlength{\tabcolsep}{10mm}
    \begin{tabular}{ccc} \Xhline{1pt}
        \makecell[c]{\textbf{运算符}} & \makecell[c]{\textbf{功能}} & \makecell[c]{\textbf{示例}} \\ \Xhline{1pt}
        \texttt{<} & 小于 & \texttt{expr < expr} \\
        \texttt{<=} & 小于等于 & \texttt{expr <= expr} \\
        \texttt{==} & 小于等于 & \texttt{expr == expr} \\
        \texttt{!=} & 不等于 & \texttt{expr != expr} \\
        \texttt{>=} & 大于等于 & \texttt{expr >= expr} \\
        \texttt{>} & 大于 & \texttt{- expr} \\
        \Xhline{1pt}
    \end{tabular}
    \caption{关系运算符}
    \label{tab::relop_operator}
\end{table}

通过比较操作数的大小关系，关系表达式将产生一个布尔值的结果，当关系满足时，关系表达式的值为\texttt{true}，否则为\texttt{false}。关系运算符允许使用以下几种操作数的组合：
\begin{gather*}
    \bm{integer} \quad relop \quad \bm{integer} \\
    \bm{real} \quad relop \quad \bm{real} \\
    \bm{integer} \quad relop \quad \bm{real} \\
    \bm{real} \quad relop \quad \bm{integer} \\
    \bm{string} \quad relop \quad \bm{string}
\end{gather*}

所有的关系运算符都可以在类中重载，因此也可以对实例对象使用关系运算符。

\section{逻辑运算符}

逻辑运算符分为逻辑与、逻辑或和逻辑非3种。如表\ref{tab::logic_operator}所示。

\begin{table}[htb]
    \centering
    \setlength{\tabcolsep}{10mm}
    \begin{tabular}{ccc} \Xhline{1pt}
        \makecell[c]{\textbf{运算符}} & \makecell[c]{\textbf{功能}} & \makecell[c]{\textbf{示例}} \\ \Xhline{1pt}
        \texttt{\&\&} & 逻辑与 & \texttt{expr \&\& expr} \\
        \texttt{||} & 逻辑或 & \texttt{expr || expr} \\
        \texttt{!} & 逻辑非 & \texttt{! expr} \\
        \Xhline{1pt}
    \end{tabular}
    \caption{逻辑运算符}
    \label{tab::logic_operator}
\end{table}

对于逻辑与运算符，当两个操作数都为\texttt{true}时，逻辑表达式的值为\texttt{true}，否则为\texttt{false}。

对于逻辑或运算符，当两个操作数都为\texttt{false}时，逻辑表达式的值为\texttt{false}，否则为\texttt{true}。

逻辑非运算符会翻转操作数的逻辑状态。当操作数为\texttt{true}时，逻辑表达式的值为\texttt{false}，否则值为\texttt{true}。

逻辑运算符要求操作数是布尔类型，否则将尝试使用下列规则进行转换：

\begin{itemize}
    \item Nil：转换为\texttt{false}。
    \item Integer：值为\texttt{0}时转换为\texttt{false}，否则转换为\texttt{true}。
    \item Real：值为\texttt{0.0}时转换为\texttt{false}，否则转换为\texttt{true}。
    \item Instance：存在方法\texttt{tobool()}时将使用该方法的返回值，否则转换为\texttt{true}。
    \item 其他：转换为\texttt{true}。
\end{itemize}

\section{赋值运算符}

赋值运算符\texttt{=}仅出现在赋值表达式中，其左操作数必须是可写对象。赋值表达式不返回值，因此不能使用连续的赋值运算，类似\texttt{a=b=c}这样的表达式是错误的。

\section{域运算符和下标运算符}

域运算符\texttt{.}用于访问对象的一个属性或者成员，你可以对模块和实例这两种类型来使用域运算符：
\begin{lstlisting}[language=berry, numbers=none]
l = list[]
l.append('item 0')
s = l.item(0)       # 'item 0'
\end{lstlisting}

下标运算符\texttt{[]}用于访问对象的元素，例如
\begin{lstlisting}[language=berry, numbers=none]
l[2] = 10   # read by index
n = l[2]    # write by index
\end{lstlisting}
